# Health-InfraOps Logstash Configuration
# Comprehensive log processing pipeline for healthcare infrastructure

input {
  # Beats input for filebeat logs
  beats {
    port => 5044
    host => "0.0.0.0"
    ssl => false
    # ssl_certificate_authorities => ["/etc/logstash/certs/ca.crt"]
    # ssl_certificate => "/etc/logstash/certs/logstash.crt"
    # ssl_key => "/etc/logstash/certs/logstash.key"
    # ssl_verify_mode => "force_peer"
  }

  # TCP input for syslog
  tcp {
    port => 5000
    type => "syslog"
    codec => "json_lines"
  }

  # HTTP input for application logs
  http {
    port => 8080
    codec => "json"
  }

  # Dead letter queue monitoring
  dead_letter_queue {
    path => "/var/lib/logstash/dead_letter_queue"
    commit_offsets => true
    pipeline_id => "main"
  }
}

filter {
  # General parsing for unknown log types
  if [type] == "syslog" {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
  }

  # Nginx access logs
  if [fileset][name] == "access" {
    grok {
      match => { 
        "message" => '%{IPORHOST:http_host} %{IPORHOST:clientip} - %{DATA:user_name} \[%{HTTPDATE:timestamp}\] "%{WORD:http_verb} %{DATA:http_request} HTTP/%{NUMBER:http_version}" %{NUMBER:response_code} %{NUMBER:body_sent_bytes} "%{DATA:http_referer}" "%{DATA:http_user_agent}" "%{DATA:x_forwarded_for}" %{NUMBER:request_time} %{NUMBER:upstream_response_time}' 
      }
    }
    date {
      match => [ "timestamp", "dd/MMM/YYYY:HH:mm:ss Z" ]
    }
    useragent {
      source => "http_user_agent"
      target => "user_agent"
    }
    geoip {
      source => "clientip"
      target => "geoip"
    }
  }

  # Nginx error logs
  if [fileset][name] == "error" {
    grok {
      match => { 
        "message" => '%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:loglevel}\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: %{IPORHOST:clientip})?(?:, server: %{IPORHOST:server})?(?:, request: "%{WORD:http_verb} %{DATA:http_request} HTTP/%{NUMBER:http_version}")?(?:, upstream: "%{DATA:upstream}")?(?:, host: "%{IPORHOST:http_host}")?' 
      }
    }
    date {
      match => [ "timestamp", "YYYY/MM/dd HH:mm:ss" ]
    }
  }

  # MySQL logs
  if [type] == "mysql" {
    grok {
      match => { 
        "message" => '%{NUMBER:timestamp} \[%{WORD:severity}\] \[%{DATA:component}\] %{GREEDYDATA:message}' 
      }
    }
    date {
      match => [ "timestamp", "UNIX_MS" ]
    }
  }

  # MongoDB logs
  if [type] == "mongodb" {
    grok {
      match => { 
        "message" => '%{TIMESTAMP_ISO8601:timestamp} %{WORD:severity} %{DATA:component} \[%{DATA:context}\] %{GREEDYDATA:message}' 
      }
    }
    date {
      match => [ "timestamp", "ISO8601" ]
    }
  }

  # Application logs (Node.js/Python)
  if [type] == "application" {
    json {
      source => "message"
    }
    
    # Parse timestamp from application logs
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
    
    # Add healthcare specific fields
    if [patient_id] {
      fingerprint {
        source => "patient_id"
        target => "patient_id_hash"
        method => "SHA256"
        key => "health-infraops-secret-key"
      }
    }
  }

  # Infrastructure logs
  if [type] == "infrastructure" {
    grok {
      match => { 
        "message" => '%{TIMESTAMP_ISO8601:timestamp} %{WORD:loglevel} %{DATA:component} - %{GREEDYDATA:message}' 
      }
    }
    date {
      match => [ "timestamp", "ISO8601" ]
    }
  }

  # Security logs
  if [type] == "security" {
    grok {
      match => { 
        "message" => '%{TIMESTAMP_ISO8601:timestamp} %{WORD:event_type} %{DATA:user} %{IP:source_ip} %{GREEDYDATA:action}' 
      }
    }
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    
    # Anonymize sensitive data
    if [user] {
      mutate {
        gsub => [ "user", ".", "*" ]
      }
    }
  }

  # Common processing for all logs
  mutate {
    remove_field => [ "timestamp" ]
    add_field => { 
      "environment" => "%{[@metadata][environment]}"
      "infra_version" => "2.1.0"
    }
  }

  # Add geoip information for external IPs
  if [clientip] and [clientip] != "127.0.0.1" {
    geoip {
      source => "clientip"
      target => "geoip"
      database => "/usr/share/geoip/GeoLite2-City.mmdb"
    }
  }

  # Parse and structure error messages
  if [message] =~ /error|exception|fail|critical/i {
    grok {
      match => { 
        "message" => '(?<error_type>[A-Za-z]+Exception|[A-Za-z]+Error):?\s+(?<error_message>.+)' 
      }
    }
  }

  # Performance metrics extraction
  if [message] =~ /duration|time|performance/i {
    grok {
      match => { 
        "message" => '.*?(?<duration>\d+\.?\d*)\s*(ms|s|seconds?).*' 
      }
    }
  }
}

output {
  # Primary output to Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "health-infraops-logs-%{+YYYY.MM.dd}"
    user => "logstash_writer"
    password => "${LOGSTASH_ES_PASSWORD}"
    template => "/etc/logstash/templates/health-infraops-template.json"
    template_name => "health-infraops-logs"
    template_overwrite => true
    
    # Dead letter queue handling
    dead_letter_queue_enable => false
    
    # Retry policy
    retry_initial_interval => 1
    retry_max_interval => 10
    retry_on_conflict => 3
  }

  # Secondary output to file for debugging
  if [loglevel] == "ERROR" or [loglevel] == "FATAL" {
    file {
      path => "/var/log/logstash/error-logs-%{+YYYY-MM-dd}.log"
      codec => line { format => "%{@timestamp} [%{loglevel}] %{message}" }
    }
  }

  # Alerting output for critical errors
  if [loglevel] == "FATAL" or [response_code] == "5xx" {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      format => "json"
      mapping => {
        "alerts" => [
          {
            "labels" => {
              "alertname" => "LogstashCriticalError"
              "severity" => "critical"
              "environment" => "%{environment}"
              "component" => "%{component}"
            }
            "annotations" => {
              "summary" => "Critical error detected in %{component}"
              "description" => "%{message}"
            }
          }
        ]
      }
    }
  }

  # Console output for development
  if [environment] == "dev" {
    stdout { 
      codec => rubydebug 
    }
  }
}